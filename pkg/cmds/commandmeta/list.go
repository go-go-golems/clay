package commandmeta

import (
	"context"
	"strings"

	clay_command_filter "github.com/go-go-golems/clay/pkg/filters/command"
	clay_command_builder "github.com/go-go-golems/clay/pkg/filters/command/builder"
	glazed_cmds "github.com/go-go-golems/glazed/pkg/cmds"
	"github.com/go-go-golems/glazed/pkg/cmds/layers"
	"github.com/go-go-golems/glazed/pkg/middlewares"
	"github.com/go-go-golems/glazed/pkg/middlewares/row"
	"github.com/go-go-golems/glazed/pkg/settings"
	"github.com/go-go-golems/glazed/pkg/types"
	"github.com/pkg/errors"
)

// AddCommandToRowFunc is a function type that allows customization of the row output for each command.
// It takes the original command, the base row generated by the list command, and the parsed layers.
// It should return one or more rows (allowing expansion or modification) or an error.
type AddCommandToRowFunc func(cmd glazed_cmds.Command, row types.Row, parsedLayers *layers.ParsedLayers) ([]types.Row, error)

// ListCommand integrates filtering and listing of commands.
type ListCommand struct {
	*glazed_cmds.CommandDescription
	// originalCommands are needed for the AddCommandToRowFunc hook
	originalCommands []glazed_cmds.Command
	// commandDescriptions are used for indexing and filtering
	commandDescriptions []*glazed_cmds.CommandDescription
	addCommandToRowFunc AddCommandToRowFunc
}

var _ glazed_cmds.GlazeCommand = (*ListCommand)(nil)

// newListCommand creates a new ListCommand.
func newListCommand(
	originalCommands []glazed_cmds.Command,
	descriptions []*glazed_cmds.CommandDescription,
	addFunc AddCommandToRowFunc,
) (*ListCommand, error) {
	// Create glazed parameter layer for output formatting
	glazedLayer, err := settings.NewGlazedParameterLayers(
		// Set default fields for the table output
		settings.WithFieldsFiltersParameterLayerOptions(
			layers.WithDefaults(&settings.FieldsFilterFlagsDefaults{
				Fields: []string{"path", "type", "short", "tags", "source"},
			}),
		),
	)
	if err != nil {
		return nil, errors.Wrap(err, "could not create Glazed parameter layer")
	}

	// Define the flags based on FilterSettings
	filterLayer, err := clay_command_builder.NewFilterParameterLayer()
	if err != nil {
		return nil, errors.Wrap(err, "could not create filter parameter layer")
	}

	return &ListCommand{
		CommandDescription: glazed_cmds.NewCommandDescription(
			"list",
			glazed_cmds.WithShort("List and filter available commands"),
			glazed_cmds.WithLong(`Lists commands, allowing powerful filtering based on type, tags, path, name, and metadata. Supports complex queries and flexible output formatting.`),
			glazed_cmds.WithLayersList(glazedLayer, filterLayer),
		),
		originalCommands:    originalCommands,
		commandDescriptions: descriptions,
		addCommandToRowFunc: addFunc,
	}, nil
}

// RunIntoGlazeProcessor executes the list command, filtering and outputting results.
func (c *ListCommand) RunIntoGlazeProcessor(
	ctx context.Context,
	parsedLayers *layers.ParsedLayers,
	gp middlewares.Processor,
) error {
	// Create the command index for efficient filtering
	index, err := clay_command_filter.NewCommandIndex(c.commandDescriptions)
	if err != nil {
		return errors.Wrap(err, "could not create command index")
	}

	// Parse settings, including filter flags
	s, err := clay_command_builder.GetFilterSettingsFromParsedLayers(parsedLayers)
	if err != nil {
		return errors.Wrap(err, "could not initialize list settings")
	}

	// Build filter from parsed settings
	b := clay_command_builder.New()
	filter := clay_command_builder.BuildFilterFromSettings(s, b)

	// Execute search using the index
	matches, err := index.Search(ctx, filter, c.commandDescriptions)
	if err != nil {
		return errors.Wrap(err, "could not search commands")
	}

	// Create a map for quick lookup of original command by description pointer
	// This avoids iterating through originalCommands for every match
	originalCmdMap := make(map[*glazed_cmds.CommandDescription]glazed_cmds.Command)
	for _, cmd := range c.originalCommands {
		originalCmdMap[cmd.Description()] = cmd
	}

	// Configure table processor if needed (example: reordering columns)
	tableProcessor, ok := gp.(*middlewares.TableProcessor)
	if ok {
		// Check if there already is a ReorderColumnOrderMiddleware in the row processors
		hasReorderColumnOrderMiddleware := false
		for _, middleware := range tableProcessor.RowMiddlewares {
			if _, ok := middleware.(*row.ReorderColumnOrderMiddleware); ok {
				hasReorderColumnOrderMiddleware = true
				break
			}
		}
		if !hasReorderColumnOrderMiddleware {
			// Add default column order if not already present
			tableProcessor.AddRowMiddleware(
				row.NewReorderColumnOrderMiddleware(
					[]string{"path", "type", "short", "long", "tags", "source"}),
			)
		}
	}

	// Output results as rows
	for _, desc := range matches {
		// Base row creation
		row_ := types.NewRow(
			types.MRP("name", desc.Name),       // Keep simple name here
			types.MRP("path", desc.FullPath()), // Full path is more useful as identifier
			types.MRP("type", desc.Type),       // Use Type from description
			types.MRP("tags", strings.Join(desc.Tags, ",")),
			types.MRP("short", desc.Short),
			types.MRP("long", desc.Long),
			types.MRP("source", desc.Source),
			types.MRP("parents", desc.Parents),
		)

		rowsToProcess := []types.Row{row_}

		// Find the original command for the hook
		originalCmd, cmdFound := originalCmdMap[desc]

		// Call the hook if provided and the original command was found
		if c.addCommandToRowFunc != nil && cmdFound {
			var hookErr error
			rowsToProcess, hookErr = c.addCommandToRowFunc(originalCmd, row_, parsedLayers)
			if hookErr != nil {
				return errors.Wrapf(hookErr, "error processing command '%s' with AddCommandToRowFunc", desc.FullPath())
			}
		}

		// Add the resulting row(s) to the processor
		for _, finalRow := range rowsToProcess {
			if err := gp.AddRow(ctx, finalRow); err != nil {
				return errors.Wrapf(err, "could not add row for command '%s'", desc.FullPath())
			}
		}
	}

	return nil
}
